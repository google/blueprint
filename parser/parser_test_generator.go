// Copyright 2017 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file exists to autogenerate parser_test_cases.go (which is particularly verbose)
package parser

import (
	"bytes"
	"fmt"
	"strings"
)

type parserTestInput struct {
	name  string
	input string
}
type parserTestCase struct {
	name         string
	input        string
	treeProvider (func(testName string) (tree *ParseTree))
}

func getTestInputs() []parserTestInput {
	return []parserTestInput{
		{
			"empty module",
			`foo {}
			`,
		},
		{

			"empty module with newline",
			`foo {
			}
			`,
		},
		{
			"module with string property",
			`
			foo {
				name: "abc",
			}`,
		},

		{
			"module with bool property",
			`
			foo {
				isGood: true,
			}
				`,
		},
		{
			"module with multiline list property",
			`
			foo {
				stuff: ["asdf", "jkl;", "qwert",
					"uiop", "bnm,",

					"zxcv "]
			}
			`,
		},
		{
			"module with singleline list property",
			`
			foo {
				stuff: ["asdf", "jkl;", "qwert", "uiop", "bnm,"]
			}
				`,
		},
		{
			"empty list with a comment",
			`
			foo {
				stuff: [/* nothing here */]
			}
			`,
		},
		{
			"list with one element",
			`
			foo {
				stuff: ["asdf"]
			}
			`,
		},
		{
			"module with nested struct",
			`
			foo {
				stuff: {
					isGood: true,
					name: "bar"
				}
			}
			`,
		},
		{
			"commented module 1",
			`
			// comment1
			foo /* test */ {
				// comment2
				isGood: true,  // comment3
			} // comment 4
			`,
		},
		{
			"two modules",
			`
			foo {
				name: "abc",
			}

			bar {
				name: "def",
			}
			`,
		},
		{
			"variable assignments",
			`
			foo = "stuff"
			bar = foo
			baz = foo + bar
			boo = baz
			boo += foo`,
		},
		{
			"comments without module",
			`
			// comment1
			// comment2

			/* comment3
			   comment4 */
			// comment5

			/* comment6 */ /* comment7 */ // comment8
			`,
		},
		{
			"one assignment",
			`
			first = "one two three"
			`,
		},
		{
			"comments before empty module",
			`
			//two comments
			//blank line

			emptyModule {}
			`,
		},
		{
			"commented modules 1",
			`
			//blank line 1

			emptyModule {
			} //trailing comment
			//trailing comment 2

			emptyModule2 {
			}
				`,
		},
		{
			"comment modules 2",
			`
			/*test {
				test: true,
			}*/

			test {
				/*test: true,*/
			}

			// This

			/* is here */

			anotherModule {}
			`,
		},
		{
			"list concatenation",
			`
			baseList = [
				"libext2fs",
				"libext2_blkid",
			]
			largerList = baseList + ["libc"]`,
		},
		{
			"commented module with newlines",
			`
			myModule {

		    	// a blank line before a property remains as a blank line

		    	myProperty: "myValue",

		    	// a blank line after a property remains as a blank line

			}`,
		},
		{
			"module with newlines",
			`
			moduleContainingSpaces {

			propertyOne: "ImFirst",

			propertyTwo: "ImLast",

				}
			`,
		},
	}
}

func generateParserTestCasesDotGo() (code string) {
	components := []string{}
	components = append(components, `// Copyright 2017 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is autogenerated by parser_test_generator.go
package parser

var parserTestCases = getParserTestCases()

func getParserTestCases() []parserTestCase {
	return []parserTestCase{
`)
	smallIndent := "\t\t"
	bigIndent := smallIndent + "\t"
	for _, testCase := range getTestInputs() {
		components = append(components, smallIndent, "{\n")
		components = append(components, bigIndent, fmt.Sprintf("%q,\n", testCase.name))
		components = append(components, bigIndent, fmt.Sprintf("`%s`,\n", testCase.input))
		parseTree, _ := ParseAndEval(testCase.name, strings.NewReader(testCase.input), NewScope(nil))
		printed := PrintTestTree(parseTree)
		components = append(components, printed)
		components = append(components, smallIndent, "},\n")
	}

	components = append(components, `	}
}
`)
	return strings.Join(components, "")
}

// prints a ParseTree as a testcase
func PrintTestTree(parseTree *ParseTree) (testCode string) {
	printer := testcasePrinter{parseTree, bytes.Buffer{}, 4}
	return printer.printTree()
}

type testcasePrinter struct {
	parseTree *ParseTree
	output    bytes.Buffer
	indent    int
}

func (p *testcasePrinter) printTree() (testCode string) {
	p.printText(
		`			func(testName string) (parseTree *ParseTree) {
				b := NewParseTreeBuilder(testName)
`)
	for _, node := range p.parseTree.SyntaxTree.nodes {
		p.printIndent()
		p.printText("b.Add(\n")
		p.indent++
		p.printNode(node)
		p.indent--
		p.printIndent()
		p.printText(")\n")
	}
	p.printText(
		`				return b.Build()
			},
`)
	return p.output.String()
}
func (p *testcasePrinter) printNode(node ParseNode) {
	switch node := node.(type) {
	case *Assignment:
		p.printAssignment(node)
	case *Module:
		p.printModule(node)
	case *String:
		p.printString(node)
	case *Variable:
		p.printVariable(node)
	case *Token:
		p.printToken(node)
	case *Operator:
		p.printOperator(node)
	case *Bool:
		p.printBool(node)
	case *List:
		p.printList(node)
	case *ListBody:
		p.printListBody(node)
	case *Map:
		p.printMap(node)
	case *MapBody:
		p.printMapBody(node)
	case *Property:
		p.printProperty(node)
	case *Comment:
		p.printComment(node)
	default:
		panic(fmt.Sprintf("Unrecognized type %T for node %#v", node, node))
	}
}
func (p *testcasePrinter) printAssignment(assignment *Assignment) {
	p.enter(assignment, "Assignment")
	p.printToken(assignment.Name)
	p.printNode(assignment.Value)
	p.printNode(assignment.OrigValue)
	p.printToken(assignment.Assigner)
	p.printTrueOrFalse(assignment.Referenced)
	p.exit(assignment)
}
func (p *testcasePrinter) printModule(module *Module) {
	p.enter(module, "Module")
	p.printToken(module.Type)
	p.printMap(module.Map)
	p.exit(module)
}
func (p *testcasePrinter) printString(str *String) {
	p.enter(str, "String")
	p.printIndent()
	p.printText(fmt.Sprintf("%s,\n", str))
	p.exit(str)
}
func (p *testcasePrinter) printToken(token *Token) {
	p.enter(token, "Token")
	p.printIndent()
	p.printText(fmt.Sprintf("%q,\n", token.Value))
	p.exit(token)
}
func (p *testcasePrinter) printVariable(variable *Variable) {
	p.enter(variable, "Variable")
	p.printToken(variable.NameNode)
	p.printNode(variable.Value)
	p.exit(variable)
}
func (p *testcasePrinter) printOperator(operator *Operator) {
	p.enter(operator, "Operator")
	p.printString(operator.OperatorToken)
	p.printNode(operator.Value)
	p.printIndent()
	p.printText("[2]Expression{\n")
	p.indent++
	p.printNode(operator.Args[0])
	p.printNode(operator.Args[1])
	p.indent--
	p.printIndent()
	p.printText("},\n")
	p.exit(operator)
}
func (p *testcasePrinter) printTrueOrFalse(value bool) {
	var s string
	if value {
		s = "true"
	} else {
		s = "false"
	}
	p.printIndent()
	p.printText(s + ",\n")
}
func (p *testcasePrinter) printBool(bool *Bool) {
	p.enter(bool, "Bool")
	p.printTrueOrFalse(bool.Value)
	p.exit(bool)
}
func (p *testcasePrinter) printList(list *List) {
	p.enter(list, "List")
	p.printListBody(list.ListBody)
	p.exit(list)
}
func (p *testcasePrinter) printListBody(listBody *ListBody) {
	p.enter(listBody, "ListBody")
	p.printIndent()
	p.printText("[]Expression{")
	if len(listBody.Values) > 0 {
		p.printText("\n")
		p.indent++
		for _, item := range listBody.Values {
			p.printNode(item)
		}
		p.indent--
		p.printIndent()
	}
	p.printText("},\n")
	p.printTrueOrFalse(listBody.NewlineBetweenElements)
	p.exit(listBody)
}
func (p *testcasePrinter) printMap(m *Map) {
	p.enter(m, "Map")
	p.printMapBody(m.MapBody)
	p.exit(m)
}
func (p *testcasePrinter) printMapBody(mapBody *MapBody) {
	p.enter(mapBody, "MapBody")
	p.printIndent()
	p.printText("[]*Property{")
	if len(mapBody.Properties) > 0 {
		p.printText("\n")
		p.indent++
		for _, property := range mapBody.Properties {
			p.printProperty(property)
		}
		p.indent--
		p.printIndent()
	}
	p.printText("},\n")
	p.exit(mapBody)
}
func (p *testcasePrinter) printProperty(property *Property) {
	p.enter(property, "Prop")
	p.printIndent()
	p.printText(fmt.Sprintf("%q,\n", property.Name))
	p.printNode(property.Value)
	p.exit(property)
}

func (p *testcasePrinter) printComment(comment *Comment) {
	p.printIndent()
	p.printText("b.Comment(\n")
	p.indent++
	p.printIndent()
	switch comment.Type {
	case FullLineText:
		p.printText(fmt.Sprintf("NewFullLineComment(%q),\n", comment.Text))
	case InlineText:
		p.printText(fmt.Sprintf("NewInlineComment(%q),\n", comment.Text))
	case FullLineBlank:
		p.printText("NewBlankLine(),\n")
	default:
		panic(fmt.Sprintf("unrecognized comment type %#v", comment))
	}
	p.printPosition(comment)
	p.indent--
	p.printIndent()
	p.printText("),\n")
}
func (p *testcasePrinter) printComments(comments []*Comment) {
	p.printIndent()
	if len(comments) < 1 {
		p.printText("nil,\n")
		return
	}
	p.printText("[]*Comment{\n")
	p.indent++
	for _, comment := range comments {
		p.printComment(comment)
	}
	p.indent--
	p.printIndent()
	p.printText("},\n")
}
func (p *testcasePrinter) printPreComments(parseNode ParseNode) {
	p.printComments(p.parseTree.SyntaxTree.GetComments(parseNode).PreComments())
}
func (p *testcasePrinter) printPostComments(parseNode ParseNode) {
	p.printComments(p.parseTree.SyntaxTree.GetComments(parseNode).PostComments())
}
func (p *testcasePrinter) printPosition(parseNode ParseNode) {
	position := p.parseTree.SourcePosition(parseNode)
	p.printIndent()
	p.printText(fmt.Sprintf("b.Pos(%v, %v, %v),\n", position.Offset, position.Line, position.Column))
}
func (p *testcasePrinter) enter(parseNode ParseNode, name string) {
	p.printIndent()
	p.printText("b." + name + "(\n")
	p.indent += 1
	p.printPreComments(parseNode)
}
func (p *testcasePrinter) exit(parseNode ParseNode) {
	p.printPostComments(parseNode)
	p.printPosition(parseNode)
	p.indent -= 1
	p.printIndent()
	p.printText("),\n")
}
func (p *testcasePrinter) printText(text string) {
	p.output.WriteString(text)
}
func (p *testcasePrinter) printIndent() {
	p.printText(strings.Repeat("\t", p.indent))
}
